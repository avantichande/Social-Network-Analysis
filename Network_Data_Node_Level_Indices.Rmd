---
title: 'INFX 576: Problem Set 1 - Network Data and Node-Level Indices\footnote{Problems originally written by C.T. Butts (2009)}'
author: "Avanti Chande"
date: 'Due: Thursday, January 19, 2017'
output: pdf_document
---
<!-- This syntax can be used to add comments that are ignored during knitting process. -->

##### Collaborators: Jay Chauhan, Gosuddin Siddiqi, Suchitra Sundararaman

##### Instructions: #####

Before beginning this assignment, please ensure you have access to R and RStudio. 

1. Download the `problemset1.Rmd` file from Canvas. Open `problemset1.Rmd` in RStudio and supply your solutions to the assignment by editing `problemset1.Rmd`. 

2. Replace the "Insert Your Name Here" text in the `author:` field with your own full name. Any collaborators must be listed on the top of your assignment. 

3. Be sure to include well-documented (e.g. commented) code chucks, figures and clearly written text chunk explanations as necessary. Any figures should be clearly labeled and appropriately referenced within the text. 

4. Collaboration on problem sets is acceptable, and even encouraged, but each student must turn in an individual write-up in his or her own words and his or her own work. The names of all collaborators must be listed on each assignment. Do not copy-and-paste from other students' responses or code.

5. When you have completed the assignment and have **checked** that your code both runs in the Console and knits correctly when you click `Knit PDF`, rename the R Markdown file to `YourLastName_YourFirstName_ps1.Rmd`, knit a PDF and submit the PDF file on Canvas.

##### Setup: #####

In this problem set you will need, at minimum, the following R packages.

```{r Setup, message=FALSE}
# Load standard libraries
library(statnet)

# Load data
load("problemset1_data.Rdata")
ls() # Print objects in workspace to see what is available
```

#### Problem 1: Two-Mode Network Data ####

After loading the data for this problem set, you can use the `ls()` command to reveal the object `sw.incidence` This is the incidence matrix for the famous "Southern Women" dataset from Davis, Gardner, and Gardner's 1941 study of class and social interaction in the Deep South[^2]. The matrix shows the attendance of 18 women at 14 informal social events during a nine-month observation period, based on various data sources such as interviews, guest lists, and participant observation. This is clearly two-mode data, with individuals as the "row vertices" and events as the "column vertices".

[^2]:  Davis, Gardner, and Gardner.  (1941) \emph{Deep South}. Chicago: The University of Chicago Press.

##### (a) Exploring Network Data ##### 

Begin by printing the matrix, and plotting it using `plot.sociomatrix`. Who seems to be the most active? Are all the women active in the same events? Describe what you observe.
```{r}
sw.incidence
?plot.sociomatrix
plot.sociomatrix(sw.incidence)
```

Evelyn, Theresa and Nora seem particularly active. 
There is a division of the events these women are interested in. The upper half section of the women are clearly interested in events E1 to E9. Lower half of the women are interested in events E7 to E14. That said, there is also an overlap in the middle where women are interested in events E5 through E9. 

##### (b) One-Mode Projections #####

Consider how these women are connected through events. To do this, form the (valued) row projection of `sw.incidence` and say it as `sw.p2p`. You might find it helpfull to know that `%*%` is R's inner product operator, and `t()` is a function to transpose a matrix. `sw.p2p[i,j]` should now be the number of events that *i* and *j* have in common. Plot this matrix as in part (a) and answer the following:

```{r}
sw.p2p <- sw.incidence %*% t(sw.incidence)
sw.p2p
plot.sociomatrix(sw.p2p)
?plot.sociomatrix
```


* What does the row projection tell us about how people are connected in this social group? 
The projection tells us that there are groups of women who attend the same events. And there are groups of women who don't attend the same events. There is a specially noticable difference between the upper and lower half sections of the women. Women in the center form an important part of the connection from the 'vitality' point of view.
In addition, it tells us about the 'reach' of certain women in terms of similar interests they share which makes them attend the same events. (Hypothesis).

* Does the group seem to have subdivision? 
Yes. The group seems to have a clear subdivision. Evelyn, laura, theresa and Brenda make the most significant subdivision followed by Katherine, Sylvia, Nora and Helen. 

* Do some members seem more "central" than others? If so, who?
In terms of degree centrality, Evelyn and  Theresa seem to be the most central. In terms of betweenness, Ruth seems to be central as she is the bridge between the two groups. Also, Helen and Nora have high betweenness. In terms of closeness, again, Evelyn, Theresa, Nora, Helen, Ruth, Verne seem to be more central than the others.

```{r}
sw.p2p
degree(sw.p2p, cmode="indegree")
degree(sw.p2p, cmode="outdegree")
betweenness(sw.p2p)
closeness(sw.p2p)
```


##### (c) Entailment Structures #####

Now, we are going to explore the \emph{entailment structures} of women and events. We can construct a row-wise entailment matrix using the following code. The new matrix will be a person by person matrix such that `sw.r.entail[i,j]==1` if person $j$ attends all of person $i$'s events. 

Use this function to create the entailment matrices (row-wise and column-wise) and produce a visualization of the entailment network for each case.

```{r} 
# Code to determine the row-wise entailment structure
# Create a new empty matrix
sw.r.entail <- matrix(0, nc=nrow(sw.incidence), nr=nrow(sw.incidence))
# Populate the matrix using a nested 'for' loop
for (i in 1:nrow(sw.incidence)){ # Pick an women i
  for (j in 1:nrow(sw.incidence)){ # And and women j
    sw.r.entail[i,j] <- all(sw.incidence[j,] >= sw.incidence[i,]) # Compare them 
  }
}
rownames(sw.r.entail) <- rownames(sw.incidence) # Renames the nodes
colnames(sw.r.entail) <- rownames(sw.incidence)

# Plot the row-wise entailment structure
gplot(sw.r.entail, label=rownames(sw.r.entail), label.cex=.7, 
      boxed.labels=FALSE, vertex.cex=1.5)

sw.r.entail
```


```{r} 
# Code to determine the column-wise entailment structure
# Create a new empty matrix
sw.c.entail <- matrix(0, nc=ncol(sw.incidence), nr=ncol(sw.incidence))
# Populate the matrix using a nested 'for' loop
for (i in 1:ncol(sw.incidence)){ # Pick an women i
  for (j in 1:ncol(sw.incidence)){ # And and women j
    sw.c.entail[i,j] <- all(sw.incidence[,j] >= sw.incidence[,i]) # Compare them 
  }
}
rownames(sw.c.entail) <- colnames(sw.incidence) # Renames the nodes
colnames(sw.c.entail) <- colnames(sw.incidence)

# Plot the columne-wise entailment structure
gplot(sw.c.entail, label=rownames(sw.c.entail), label.cex=.7, 
      boxed.labels=FALSE, vertex.cex=1.5)
```

Use the matrices and visualizations to answer:

* What does a path tell us?
Row-wise Entailment: The path tells us the direction in which a particular woman has attended another woman's events. For example, the path between Myrna, Katherine and Sylvia suggest that Myrna has attended all of the events that Katherine has attended and Evelyn has attended all the events that Katherine has attended, but the opposite is not true.

Column-wise Entailment: The path in the column-wise entailment tells us that all who women who attend a particular event also attend another event. For example, all women who attend event 4 also attend event 3 and all women who attended event 3 also attended event 5. but the opposite is not true. 

* What do mutual (i.e. bidirectional) dyads mean?
For row wise entailment, mutual dyads mean that both women have attended the other's events. In other words, they attended the same events. 
For columnwise entailment, it means that the events were attended by the same women.

* What is special about isolates?
Special thing about Isolates is that they are connected with both of the subdivisions of this social group. For row-wise entailment, Helen is an isolate. It means that she attends events that are attended by both subdivisions. For example, Evelyn attends some of Helen's events and Nora also attends some of Helen's events. This establishes a connection for Helen from a vitality and reach point of view. 

For coulumn wise entailment, Events E7, E9 and E11 are isolates. It means that these events are attended by diverse women. We can say that these events are meeting points for the women from the upper-right and lower-left subdivisions of this social group.

#### Problem 2: Node-Level Indices and Hypothesis Tests ####
In the data for this assignment, you will find the following network objects: `silsys.ad.ilas` and `silsys.fr.ilas`. These are network objects containing data from David Krackhardt's famous Silican Valley Systems study.[^3] The two networks consist of advice-seeking ties and friendship ties (respectively). In addition each network contains several other attributes. 

[^3]: Krackhardt, David. (1990) "Assessing the Political Landscape: Structure, Cognition, and Power in Organizations." \emph{ASQ}, 35(2): 342-369.

##### (a) Computing Node-Level Indices #####
Compute indegree, outdegree, betweenness and eigenvector centrality scores for all individuals in each of the two networks. A useful trick to combine vectors or matrices `a`, `b`, and `c` into a single matrix using the `cbind` command as follows: `cbind(a,b,c)`. Print the centrality scores. 
```{r}
#Network 1 - Advise Seeking network - silsys.ad.ilas
#Indegree
indeg_silsys_ad_ilas = degree(silsys.ad.ilas, cmode="indegree")

#OutDegree
outdeg_silsys_ad_ilas = degree(silsys.ad.ilas, cmode="outdegree")
all(degree(silsys.ad.ilas) == indeg_silsys_ad_ilas+outdeg_silsys_ad_ilas)

#Betweenness
bet_silsys_ad_ilas = betweenness(silsys.ad.ilas)

#Eigen Vector Centrality
evcent_silsys_ad_ilas = evcent(silsys.ad.ilas)

#Combining the vectors
centrality_scores_Ad = cbind(indeg_silsys_ad_ilas,outdeg_silsys_ad_ilas, bet_silsys_ad_ilas, evcent_silsys_ad_ilas )

colnames(centrality_scores_Ad) = c('Indegree', 'OutDegree','Betweeness', 'Eigen-Vector-Centrality')
centrality_scores_Ad

#Network 2 - Friendship Ties network - silsys.fr.ilas

#Indegree
indeg_silsys_fr_ilas = degree(silsys.fr.ilas, cmode="indegree")

#OutDegree
outdeg_silsys_fr_ilas = degree(silsys.fr.ilas, cmode="outdegree")
all(degree(silsys.fr.ilas) == indeg_silsys_fr_ilas+outdeg_silsys_fr_ilas)

#Betweenness
bet_silsys_fr_ilas = betweenness(silsys.fr.ilas)

#Eigen Vector Centrality
evcent_silsys_fr_ilas = evcent(silsys.fr.ilas)

#Combining the vectors
centrality_scores_Fr = cbind(indeg_silsys_fr_ilas,outdeg_silsys_fr_ilas, bet_silsys_fr_ilas, evcent_silsys_fr_ilas )

colnames(centrality_scores_Fr) = c('Indegree', 'OutDegree', 'Betweenness', 'Eigen-Vector-Centrality')

centrality_scores_Fr

```


* Who are some of the most central individuals in the advice-seeking network? In the friendship network?

The most central individual in the advise-seeking network are  the 19th and 5th individuals according to indegree. The 19th individual also has the highest betweenness(370) and also a good eigen vector centrality measure.According to outdegree, 25th and 13th individuals are the most central. 25th individual also has a high eigen vector centrality.

The most central individual in the friendship network is the 29th individual. She has the highest indegree(12) and the highest outdegree(16). She also has the highest betweenness(203) and a high eigen vector centrality. 

##### (b) Comparing Node-Level Indices #####

The `cor` command calculates correlations. You can apply this function to a matrix to compute the correlation matrix - correlations for all pairs of columns. Compute the within and between network correlation matrices for the centrality scores you computed in part (a). Print this table and answer the following:

```{r}
cor(centrality_scores_Ad)
cor(centrality_scores_Fr)
cor(centrality_scores_Fr, centrality_scores_Ad)
```


* Does centrality in the advice-seeking network correspond (or not) to centrality in the friendship network?
1. The centrality measures in the advises-seeking network correspond to the same in the friendship network in some cases and doesnot correspond in some other cases. For example, indegree and betweenness in the advise-seeking network are correlated, the same are strongly correlated in the friendship network. 
2. However, eigen-vector centrality and indegree are not correlated in the advise-seeking network, but highly correlated in the friendship network.
3. Similarly, outdegree and indegree are strongly correlated in the friendship network, but not correlated in the advise-seeking network. This means that the those who advise, do not go out seeking advise. But those who're friends with many people, also seek out new friendship ties.

* What centrality measures are most strong correlated? Least strongly correlated?
When considering within the friendship network centralities, eigen vector centrality and outdegree are the most strongly correlated. (0.94) and Eigen vector centrality and betweenness are the least strongly correlated.

When considering within the advising network centralities, Eigenvector centrality and outdegree are the most strongly correlated, and Indegree and Eigen vector centrality are the least strongly correlated.

When considering between networks centralities, both their betweenness are the most strongly correlated; whereas both their eigen vector centralities are the least strongly correlated.


##### (c) Relating Node-Level Indices to Covariates #####

In the in-class demo you were given a function for testing the correlation between vectors using a permutation test. Using this function, assess the relationship between the "Charisma" (charisma, as rated by fellow employees) and "Potency" (ability to overcome opposition in order to achieve goals, as rated by fellow employees) vertex attributes and the centrality scores you computed in part (a). 

Remember you can extract vertex attributes from network objects with the `%v%` operator or the `get.vertex.attribute` function. Report the results of these tests as a table showing the observed correlation of each attribute with each centrality measure, along with the two-sided $p$-value for the appropriate test in each case. 
```{r}
charisma = get.vertex.attribute(silsys.fr.ilas, 'Charisma')
potency = get.vertex.attribute(silsys.fr.ilas, 'Potency')
charisma
potency
```


```{r}
perm.cor.test<-function(x,y,alternative ="two-sided", niter=5000){  #Define a simple test function
  c.obs <<-cor(x,y,use="complete.obs")
  c.rep <<-vector()
  for(i in 1:niter)
    c.rep[i]<-cor(x,sample(y),use="complete.obs")
  
  pvalue <<- mean(abs(c.rep)>=abs(c.obs))
  
  result <- c(c.obs, pvalue)
  return(result)
}
```


```{r}
#Charisma and Centrality in Friendship Network

p1 = perm.cor.test(charisma, indeg_silsys_fr_ilas)
p2 = perm.cor.test(charisma, outdeg_silsys_fr_ilas)
p3 = perm.cor.test(charisma, bet_silsys_fr_ilas)
p4 = perm.cor.test(charisma, evcent_silsys_fr_ilas)

#Potency and Centrality in Friendship Network

p5 = perm.cor.test(potency, indeg_silsys_fr_ilas)
p6 = perm.cor.test(potency, indeg_silsys_fr_ilas)
p7 = perm.cor.test(potency, bet_silsys_fr_ilas)
p8 = perm.cor.test(potency, evcent_silsys_fr_ilas)

#Charisma and Centrality in Advising Network

p13 = perm.cor.test(charisma, indeg_silsys_ad_ilas)
p14 = perm.cor.test(charisma, outdeg_silsys_ad_ilas)
p15 = perm.cor.test(charisma, bet_silsys_ad_ilas)
p16 = perm.cor.test(charisma, evcent_silsys_ad_ilas)

#Potency and Centrality in Advising Network
p9 = perm.cor.test(potency, indeg_silsys_ad_ilas)
p10 = perm.cor.test(potency, outdeg_silsys_ad_ilas)
p11 = perm.cor.test(potency, bet_silsys_ad_ilas)
p12 = perm.cor.test(potency, evcent_silsys_ad_ilas)

#Combining them in a Table

table = data.frame(rbind(p1,p2,p3,p4,p5,p6,p7,p8,p13,p14,p15,p16,p9,p10,p11,p12))
table
colnames(table) = c("Observed Correlation", "Two-sided Pvalue")
row.names(table) = c("charisma_fr_indegree", "charisma_fr_outdegree", "charisma_fr_betweenness","charisma_fr_eigenvectorcen","potency_fr_indegree", "potency_fr_outdegree","potency_fr_betweenness", "potency_fr_eigenvectorcen", "charisma_ad_indegree", "charisma_ad_outdegree", "charisma_ad_betweenness","charisma_ad_eigenvectorcen","potency_ad_indegree", "potency_ad_outdegree","potency_ad_betweenness", "potency_ad_eigenvectorcen")

table
```


* How to charisma and potency appear to relate to positional structure at Silicon Valley Systems?
It's interesting to see that the potency is correlated with the advertising structure's indegree centralities (0.58) at silicon valley systems. This means that potency matters in the advise seeking network.There is also a slight negative correlation between charisma and outdegree of the advise seeking network, but we can't reject our null hypothesis that there is no association between charisma and outdegree since the two-sided p-value is greater than 0.05.(0.09)